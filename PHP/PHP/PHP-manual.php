<?php
/*
基本语法：
  PHP标记：
    当解析一个文件时，PHP会寻找起始和结束标记，也就是<?php和?>,告诉PHP开始和停止解析二者之间的代码。
    PHP也允许使用段标记<?和?>，但不推荐。
    如果文件内容是纯PHP代码，最好在文件末尾删除PHP结束标记，这可以避免在PHP结束标记之后万一意外加入了空格或者换行符，会导致PHP开始输出这些空白，而脚本中此时并无输出的意图。
  从HTML中分离：
    凡是在一对开始和结束标记之外的内容都会被PHP解析其忽略，这使得PHP文件可以具备混合内容，可以嵌入到HTML文档中去。
	当PHP解析其碰到?>结束标记时就简单地将其后内容原样输出，直到碰到下一个开始标记。
	例外：
	  1.马上紧接换行-指令分隔符
	  2.处于条件语句中间时，此时PHP解析器会根据条件判断来决定哪些输出，哪些跳过。
  指令分隔符：
    同C或Perl一样，PHP需要在每个语句后用分号结束指令。
  注释：
    PHP支持C、C++和Unix Shell的注释，不要嵌套C风格的注释(碰到第一个* / 时 结束)  
类型：
  简介：
　　PHP支持9种原始数据类型
    四种标量类型：boolean(布尔型),integer(整型),float(浮点型,double),string(字符串)
	三种复合类型：array(数组),object(对象),callable(可调用)
	两种特殊类型：resource(资源),NULL(无类型)
	伪类型：mixed(混合类型),number(数字类型),callbak(回调类型，又称callable),array|object(数组|对象类型),void(无类型)
    伪变量$...
	查看某个表达式的值和类型，用var_dump()函数
	得到一个易读懂的类型的表达式方式用于调用，用gettype()函数
	  $a_bool = true;
	  echo gettype($a_bool);   //输出boolean
	要检验某个类型，不要用gettype() ，而用is_type函数，如is_int,is_string等。
	判断变量的类型:gettype(),is_array(),is_float(),is_int(),is_object()和is_string()。
	如果要将一个变量强制转换为某类型，可以对其使用强制转换或者settype()函数。
  Boolean类型：
    boolean表达了真值，可以为TRUE或FALSE。
	要指定一个布尔值，可以使用常量TRUE或FALSE，两个都不区分大小写。
	  $foo = true;
	通常运算符所返回的boolean值结果会被传递给控制流程。
	当转换为boolean时，以下值被认为是false:FALSE,0,0.0,空字符串"","0",不包括任何元素的数组,NULL,尚未赋值的变量。
  Integer类型：
    整型值可以使用十进制，十六进制(0x)，八进制(0)或二进制(0b)
	如果给定的一个数或运算后的结果超出了integer的范围，值将会被解释为float
	PHP中没有整除的运算符。值可以舍弃小数部分，强制转换为integer,或者使用round()函数进行四舍五入。
	var_dump((int)(25/7))  //int(3)
	var_dump(round(25/7))  //float(4)
	要将一个值转换为Integer，可以通过(int)(integer)强制转换，也可以通过函数intval()函数。
	只能将布尔值，浮点型和字符串转换为整型。
  Float类型：
    也叫浮点数float,双精度数double或实数real,如：1.234,1.2e3,7E-10。
	由于内部表达式方式的原因，比较两个浮点数是否相等是有问题的。
  String类型：
    一个字符串就是由一系列的字符组成，其中每个字符等同于一个字节。不支持unicode。
	4种表达方式：
	  单引号：要表达一个单引号自身，需要在它前面加反斜线(\)来转义，要表达反斜线自身，则用2个反斜线(\\)。其他任何方式的反斜线都会被当成 反斜线本身。
	    在单引号字符串中的变量和特殊字符的转义序列将不会被替换。
	  双引号：PHP将对一些特殊的字符进行解析。
	  Heredoc语法结构：类似于双引号字符串
	    $bar = <<<EOT
		welcome to beijing
		EOT;
	  nowdoc语法结构：类似于单引号字符串
	    $bar = <<<'EOT'
		welcome to beijing
		EOT;
	变量解析:
	  当字符串用双引号或heredoc结构定义时，其中的变量将会被解析。
	  两种语法规则：简单规则、复杂规则。
	    简单规则：在一个string中嵌入一个变量、array、object。
		  当PHP解析器遇到一个美元符号时，它会组合尽量多的标识以形成一个合法的变量名。，可以用花括号来明确变量名的界限。
		  echo "$john"."$book[1]";
		复杂规则:显著标记是用花括号包围的表达式。由于{无法被转义，只有$紧挨着{时才会被识别。
		echo "this is {$great}"."this works:{$arr['key']}"."{$arr[2][3]}"
	存取和修改字符串中的字符：
	  string中的字符可以通过一个从0开始的下标，用类似array结构中的方括号包含对应的数字来访问和修改。可以把string当成字符组成的array。
	  $first=$str[0];$third=$str[2];$last=$str[strlen($str)-1];$str[strlen($str)-1]='e';
	有用的函数和运算符：
	  字符串可以用"."运算符连接起来。可以参考字符串函数。
	转换成字符串： 
	  一个值可以通过在其前面加上(string)或用strval()函数来转变成字符串。
  Array类型：
    PHP中的数组实际上是一个有序映射。映射是一种把values关联到Keys的类型。
	定义数组：$arr = array(key1=>value2,key2=>value2,...);
			  $arr = [key1=>value2,key2=>value2,...];
	最后一个数组单元之后的逗号可以省略，通常用于单行数组定义中，多行数组最后一个逗号最好保留，方便添加新单元。
	PHP实际并不区分索引数组和关联数组，所以可以同时含有Integer和string类型的键名。
	用方括号语法访问数组单元array[key]。
	初始化变量的最好方式是直接给其赋值，不推荐用方括号的语法给数组赋值 。
	要修改某个值，通过其键名给该单元赋一个新值。要删除某个键值，对其调用unset()函数。
	  $arr[4]='ok';           unset($arr[5]);
	  unset不会重建索引，还是会用之前的索引或键值对。要重建索引，可以用array_values()函数。
	数组函数：
	  count()函数用来数出数组中元素的个数。
  Object类型：
    要创建一个新的对象object，使用new语句实例化一个类。
	参见类与对象章节
  Resource资源类型：
    保存了到外部资源的一个引用，保存有为打开文件、数据库连接、图形画布区域等的特殊句柄。
  NULL:表示变量没有值，NULL类型的唯一可能的值就是不区分大小写的常量NULL。
    以下情况变量被认为是NULL：被赋值为NULL，尚未被赋值，被unset() 。
  Callback/Callable类型：
  本文档中使用的伪类型与变量：
  类型转换的判别：
    PHP在变量定义中不需要明确的类型定义，变量类型是根据使用该变量的上下文所决定的。
	要改变一个变量的类型，参见settype()；
	类型强制转换：在要转换的变量之前加上用括号括起来的目标类型。
	  (int)(integer)(float)(double)(real)(bool)(boolean)(string)(array)(object)(unset)
变量：
  基础：
    PHP中的变量用一个美元符号后面跟变量名来表示,变量名区分大小写。
    变量名由字母或者下划线开头，后面跟上任意数量的字母、数字或者下划线。
    变量默认总是传值赋值:改变其中一个变量的值，将不会影响到另外一个变量。
    变量引用赋值：简单的将一个&符号加到变量前(源变量)。改动新的变量将影响到原始变量，反之亦然。
    对变量初始化是个好习惯，未初始化的变量具有类型的默认值。用isset()来检测一个变量是否已经被初始化。
  预定义变量：
    PHP提供了大量的预定义变量，这些变量依赖于运行的服务器的版本和设置，有所不同。
    参阅预定义变量一章
	PHP提供了一套附加的预定数组，包含了web服务器，运行环境和用户输入的数据，这些数组全局范围内自动生效。因此通常称为自动全局变量或者超全局变量。
	超全局变量不能被用作函数或者类方法中的可变变量。
  变量范围：
    变量的范围即它定义的上下文背景(也就是它生效范围)，大部分变量只有一个单独的范围。
	在用户自定义函数中，一个局部函数范围将被引入，任何用于函数内部的变量按缺省情况将被限制在局部函数范围内。
	PHP中全局变量在函数中使用时必须声明为global,之后对任一变量的所有引用都会指向其全局版本。
	超全局变量在任何范围都有效，在函数中并不需要global声明。如：$_POST[].
	global关键字：function sum(){global $a,$b;$b=$a+$b;}
	$GLOBALS数组：function sum(){$GLOBALS['b']=$GLOBALS['a']+$GLOBALS['b'];}
	例如：function text(){global $HTTP_POST_VARS;echo $HTTP_POST_VARS['name'];}
	静态变量：静态变量仅在局部函数域中存在，但当程序执行离开此作用域时，其值并不丢失。
  可变变量： 一个变量的变量名可以动态的设置和使用。
    $a='hello';
	$$a='world';  //相当于$hello='world';
	echo "$a ${$a}";  //hello world 
  来自PHP之外的变量：
    HTML表单：magic_quotes_gpc配置指令影响到GET，POST和COOKIE的值，已经过时应该关闭。
	IMAGE SUBMIT变量名：<input type="image" src="image.gif" name="sub" />
	  当用户电机到图像中的某处时，相应的表单会被传送到服务器，并加上两个个变量sub_x和sub_y,他们包含了用户点击图像的坐标。
	HTTP COOKIES：
	  可以使用setcookie()函数设定cookies。cookies是HTTP信息头中的一部分。可在$_COOKIE和$_REQUEST中使用。
	  浏览器中一个cookie会替换掉上一个同名的cookie，除非路径或者域不同。
常量：
  常量是一个简单值的标示符(名字)，在校本执行期间该值不能改变。大小写敏感，传统上常量标识符总是大写的。
  常量的范围是全局的，可以在脚本的任何地方访问常量。
  语法：
    可以用define()函数来定义常量，在PHP5.3以后，可以使用const关键字在类定义之外定义常量。
	常量只能包含标量数据(boolean,integer,float,string)。
	通过指定其名字来取得常量的值，与变量不同，不应该在常量前面加$符号。
	使用defined()函数检查是否定义了某个常量。
	const关键字定义常量必须处于最顶端的作用域，不能在函数内，循环内以及if语句内来定义常量。
  魔术常量：
    PHP向它运行的任何脚本提供了大量的预定义常量，有八个魔术常量它们的值随着它们在代码中的位置改变而改变：
      __LINE__    //文件中的当前行号
      __FILE__    //文件的完整路径和文件名
	  __DIR__     //文件所在的目录
	  __FUNCTION__//函数名称。返回该函数被定义时的名字
	  __CLASS__   //类的名称，返回该类被定义时的名字
	  __TRAIT__   //Trait的名字，返回trait被定义时的名字
	  __METHOD__  类的方法名，返回该方法被定义时的名字
	  __NAMESPACE__//当前命名空间的名称
表达式：
  在PHP中，几乎所写的任何东西都是一个表达式。
  函数也是表达式，表达式的值即为他们的返回值。
  前后递增/递减：
    前递增：写作++$var,求增加后的值(php在读取变量的值之前，增加变量的值)
	后递增：写作$var++,求变量未递增之前的值(php在读取变量的值之后，增加变量的值)
  三元条件运算符：$first?$second:$third;
    如果第一个子表达式的值是TRUE,那么计算第二个子表达式的值，其值为整个表达式的值。否则，将是第三个表达式的值。
运算符：
  运算符是可以通过给出的一或多个值来产生另一个值的东西。
  可按照其能接受几个值来分为：一元运算符(!,++,--)、二元运算符(+,-,*)和三元运算符(?:)。
  运算符的优先级：
    必要时可以用括号来强制改变优先级，可以增加代码的可读性。
  算术运算符：+,-,*,/,%
    除法运算符总是返回浮点数。例外：两个操作数都是整数并且正好能整除，这时返回一个整数。
	取模运算符的操作数在运算之前都会被转换成整数(除去小数部分)，结果和被除数的符号(正负)相同。	
  赋值运算符：
    基本的赋值运算符是"=",不是"等于"的意思，实际上意味着把右边表达式的值赋给左边运算数。
    组合运算符：+=和.=
	赋值运算将原来变量的值拷贝到新变量中 ，所以改变其中一个并不影响另一个。
	引用赋值：$b=&$a;意味着两个变量指向同一个数据，没有拷贝。	  
  位运算符：&,|,^,~,<<,>>
  比较运算符：==,===,!=,<>,!==,<,>,<=,>=,<=>
    比较数组的方法：看手册有代码
  错误控制运算符：@，将其放置在一个PHP表达式之前，该表达式可能产生的任何错误信息都被忽略。
    @只对表达式有效，例如变量、函数、include调用、常量等之前。
  执行员算符：反引号(``)，注意这不是单引号。
    PHP将尝试将反引号中的内容作为shell命令来执行，并将其输出信息返回(即可以赋给一个变量)。
	效果与使用函数shell_exec()相同。
	反引号运算符在激活了安全模式或者关闭shell_exec()时是无效的。不能在双引号字符串中使用。
	参见程序执行函数。
  递增/递减运算符：
    ++$a,$a++,--$a,$a--
  逻辑运算符：&& || and or xor ! 
  字符串运算符：
    连接运算符(.)：返回其左右参数连接后的字符串。
	连接赋值运算符(.=):将右边参数附加到左边的参数之后。
  数组运算符：+，==，===，!=,<>,!==
    +运算符把右边的数组元素附加到左边的数组后面，两个数组中都有的键名，则只用左边数组中的，右边被忽略。
	数组中的单元如果具有 相同的键名和值则比较时相等。
  类型运算符：instanceof用于确定一个PHP变量是否属于某一类class的实例。
流程控制：
  简介：PHP脚本都是由一些列语句组成的,通常以分号结束,此外,还可以用花括号将一组语句封装成一个与剧组,语句组本身可以当作是一行语句.
  if语句:if(expr){statement} 
    expr按照布尔求值,如果expr的值为true,将执行statement,如果值为FALSE将忽略statement。
  else语句：else延伸了if语句，可以在If语句中的表达式的值为fasle时执行语句。
  elseif语句：延伸了if语句，可以在原来的If表达式的值为fasle时执行不同语句，仅在elseif的条件表达式值为TRUE时执行语句。  
  流程控制的替代语句：把左花括号换成冒号(:),右花括号换成endif,endwhile,endforeach,endswitch。
  while语句:while(expr){statement}
    只要while表达式expr的值为true就重复执行嵌套中的循环语句。表达式的值在每次开始循环时检查。
  do-while语法:do{statement}while(expr)  和while不同的是表达式的值是在循环结束时检查而不是开始时。至少会执行一次。
  for语法:for(expr1;expr2;expr3){statement} 
    第一个表达式expr1在循环开始前无条件求值并执行一次。expr2在每次循环开始前求值，如果未true则继续循环，执行嵌套的循环语句，如果未fasle则终止循环。expr3在每次循环之后被求值并执行。
	每个表达式都可以为空或包括逗号分隔的多个表达式。expr2为空则意味着无限循环下去，用break结束循环。
	对数组进行遍历(参见该处代码)
  foreach语句:提供了遍历数组的简单方式,仅能够应用于数组和对象.
    foreach($array as $value){statement}
	  遍历给定的数组$array,每次循环中，当前单元的值被赋给$value并且数组内部的指针向前移动一步(因此下一次循环中将会得到下一个单元)。
	foreach($array as $key=>$value){statement}
	  当前单元的键名也会在每次循环中被赋给变量$key
  break语句:结束当前for，foreach,while,do-while或者switch结构的执行。
    break可以接受一个可选的参数来决定跳出几重循环。break 1;(跳出当前)break 2(跳2级);
  continue语句:在循环结构用来跳过本次循环中剩余的代码，并在条件求值为真时开始执行下一次循环。
    continue可以接受一个可选的参数来决定跳出几重循环。
  swith语句:把同一个变量(表达式)与很多不同的值比较，并根据它等于那个值来执行不同的代码。
    swith语句中条件只求值一次并用来和每个case语句比较。
	swith结构可以用字符串。swith($i){case "apple":break;case "cake":break;}
	case的特例是default，它匹配了任何和其他case都不匹配的情况。
  declare:用来设定一段代码的执行命令。
  return:如果在一个函数中调用return语句，将立即结束此函数的执行并将它的参数作为函数的值返回。
  require:包含并运行指定文件。require在出错时产生E_COMPILE_ERROR级别的错误，将导致脚本终止。
  require_once:
  include:包含并运行指定文件。
    如果没有给出目录时则按照include——path指定的目录查找，如果没有在调用文件所在的目录和当前工作目录下寻找。如果找不到，则会发出一条警告。
	当一个文件被包含时，其中所包含的代码继承了include所在行的变量范围。
	要在脚本中自动包含文件，参见php.ini中的auto_preend_file和auto_append_file配置选项。
  include_once:
  goto:goto操作符可以用来跳转到程序中的另一个位置。
    goto有一定限制，目标位置只能位于同一个文件和作用域。也就是说，不能跳出函数或类方法，也不能跳入到任何循环或函数。
函数：
  用户自定义函数：
    有效的函数名以字母或下划线开头，后面跟字母‘数字、或下划线。
	函数无需在调用之前被定义，除非是函数在一些控制语句或条件语句里还没有被执行。
	PHP中的所有函数和类都具有全局作用域，可以定义在一个函数之内而在之外调用。PHP不支持函数重载。、
	函数名是 大小写无关的，不过在调用函数的时候，使用其在定义时相同形式是个好习惯。
	在PHP中可以调用递归函数。定义一个函数，在函数里面调用其自身。
  函数的参数：以逗号作为分隔符的表达式列表，从左向右求值。
    函数的参数可以定义默认值，在定义函数的时候给其赋一个值。
	function test($title="wellcome"){}
	默认值必须是常量表达式，不能是变量、类成员或者是函数调用等。默认参数必须放在任何非默认参数的右侧。	
  返回值：可以返回包括数组和对象的任意类型。返回语句会立即中止函数的运行。
    函数不能返回多个值，但是可以通过返回一个数组来得到类似的效果。
  可变函数：如果一个变量名后有圆括号，PHP将寻找与变量的值同名的函数。
  内部(内置)函数：有一些函数需要和特定的PHP扩展库一起编译，否则会报错。
    使用phpinfo()或者get_loaded_extensions()可以得知PHP加载了那些扩展库。
  匿名函数：也叫闭包函数(closures),允许临时创建一个没有指定名称的函数。
类与对象：
  简介：
  基本概念：每个类的定义都以关键字class开头，后面跟着类名，后面跟着一对花括号，里面包含有类的属性和方法的定义。
    类名可以是任何非PHP保留字的合法标签。一个类可以包含有属于自己的常量、变量(属性)以及函数(方法)。  
	$this是一个到主叫对象的引用(通常是该方法所从属的对象)
	new关键字：要创建一个类的实例，必须使用New关键字。如果new之后跟着的是一个包含有类名的字符串，则该类的一个实例被创建。
	如果该类属于一个名字空间，则必须使用其完整的名称。
	extends:一个类可以在声明中用extends关键字继承另一个类的方法和属性。不支持多重继承。
	::class：用于类名的解析。使用Classname::class可以获取类classname的完全限定名称。
  属性：属性声明是由关键字public,protected或者private开头，然后跟一个普通的变量声明来组成。
    属性中的变量可以初始化，值必须是常数。
	在类的成员方法里面,可以使用->(对象运算符)：$this->property(property是该属性名)这种方式来访问非静态属性。
	静态属性则是用::(双冒号)：self::$property来访问。
  类常量：可以把在类中始终保持不变的值定义为常量，在定义和使用常量的时候不需要使用$符号。
    常量的值必须是一个定值，不能是变量、类属性、数学运算的结果或函数调用。
  类的自动加载：sql_autoload_register()函数可以注册任意数量的自动加载器，当使用尚未被定义的类和接口时自动去加载。
    __autoload()函数也能自动加载类和接口，但是建议使用sql_autoload_register()函数。
  构造函数和析构函数：
    构造函数：具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。
	  function __construct(){...}
	析构函数：会在到某个对象的所有引用都被删除或者当对象被现实销毁时执行。
	  function __destruct(){...}
	  析构函数即时在使用exit()中止脚本运行时也会被调用。
  访问控制(可见性)：对属性或方法的访问控制，是通过在前面添加关键字public(共有),protected(受保护)private(私有)来实现的。
    公有的类成员可以在任何地方被访问，受保护的类成员则可以被其自身以及其子类和父类访问，私有的类成员则只能被其定义所在的类访问。	
  对象继承：子类会继承父类所有公有和受保护的方法。
  范围解析操作符(::)：用于访问静态成员、类常量，还可以用于覆盖类中的属性和方法。
    self,parent和static这三个特殊的关键字是用于在类定义的内部对其属性或方法进行访问。
  Static(静态)关键字：用static关键字来定义静态方法和属性。
    声明类属性或方法为静态，就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问(但静态方法可以)。
	伪变量$this在静态方法中不可用。静态属性不可以由对象通过->操作符来访问。
	静态属性只能被初始化为文字或常量，不能使用表达式。
  抽象类：定义为抽象的类不能被实例化。任何一个类，如果他里面至少有一个方法是被声明 为抽象的，那么这个类就必须被声明为抽象的。
    abstract class abstractclass{}
  对象接口：使用接口(interface),可以指定某个类必须实现那些方法，但不需要定义这些方法的具体内容。
    接口是通过Interface关键字来定义的，就象定义一个类一样，但其中定义所有的方法都是空的。
	接口中定义的所有方法都必须是公有的，要实现一个接口，使用implements操作符，类中必须实现接口中定义的所有方法。
	  interface itemplate{}  class template implements itemplate{}
	接口常量不能被子类或子接口所覆盖。
  trait:代码复用的方法。
  匿名类：可以创建一次性的简单对象。
  重载：是指动态地"创建"类属性和方法。我们是通过魔术方法来实现的。
    当调用当前环境下未定义或不可见的类属性或方法时，重载方法会被调用。
	重载方法都必须声明为Public。
	属性重载：只能在对象中进行。
	  public void __set(string $name,mixed $value)在给不可访问属性赋值时被调用
	  public void __get(string $name)读取不可访问属性时调用
	  public void __isset(string $name)当对不可访问属性调用isset()empty()时被调用
	  public void __unset(string $name)当对不可访问属性调用unset()时被调用 
	  参数$name是指要操作的变量名称。$value参数指定了$name变量的值。
	方法重载：
	  public mixed __call(string $name,array $arguments)在对象中调用一个不可访问方法是，__call()会被调用。
	  public static mixed __callStatic(string $name,array $arguments)在静态上下文中调用一个不可访问方法时，__callStatic()被调用。
  遍历对象：foreach语句，默认所有可见属性都将被用于遍历。
  魔术方法：__construct()__destruct()__call()__callStatic()_get()__set()__isset()__unset()
  __sleep()常用于提交未提交的数据，或类似的清理操作。
  __wakeup()经常用在反序列化操作中，例如重新建立数据库联接，或执行其他初始化操作
  __toString()用于一个类被当成字符串时应怎样回应。
  __invoke()当尝试以调用函数的方法调用一个对象时，__invoke()会被自动调用。
  __set_state()当调用var_export()导出类时，此静态方法会被调用。
  __clone()
  __debuginfo()等被称为魔术方法
  final关键字：
  对象复制：
  对象比较：
  类型约束：
  后期静态绑定：
  对象和引用：
  对象序列化： 
  OOP变更日志：
命名空间：
  用来解决在编写类库或应用程序时创建可重用的代码如类或函数时碰到的两类问题:
    1.用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突.
	2.为很长的标识符名称创建一个别名(或简短)的名称,提高源代码的可读性.
  PHP命名空间提供了一种将相关的类、函数和常量组合到一起的途径。
  通过关键字namespeace来声明，必须在所有代码之前声明命名空间，除了declare关键字。
  允许指定层次化的命名空间的名称。
  可以在同一个文件中定义多个命名空间，但是不建议这样做。
  如果没有定义命名空间，所有的类与函数的定义都是在全局空间。在名称前加前缀\表示该名称是全局空间中的名称。
Errors:
异常处理：
生成器：
引用的解释：
预定义变量：这些变量将所有的外部变量表示成内建环境变量，并且将错误信息表示成返回头。
  超全局变量：
	  $GLOBALS:包含了全部变量的全局组合数组，变量的名字就是数组的键。
	  $_SERVER:服务器和执行环境信息，包含了诸如头信息、路径以及脚本位置等信息的数组。
	    这个数组中的项目由 web服务器创建，不能保证每个服务器都提供所有项目。
	  $_GET:通过URL参数传递给当前脚本的变量的数组。
	  $_POST:当HTTP POST请求的content-type是application/x-www-form-urlencoded或multipart/form-data时，会将变量以关联数组形式传入当前脚本。
	  $_FILES:通过HTTP POST方式上传到当前脚本的项目的数组。
	  $_REQUEST:包含了$_GET,$_POST,$_COOKIE
	  $_SESSION:当前脚本可用SESSION变量的数组。
	  $_ENV:通过环境方式传递给当前脚本的变量的数组。这些变量被从PHP解析器的运行环境导入到PHP的全局命名空间。
	  $_COOKIE:通过HTTP COOKIES方式传递给当前脚本的变量的数组。
  $php_errormsg:包含PHP生成的最新错误信息
  $HTTP_RAW_POST_DATA:原生POST数据
  $http_response_header:HTTP响应头，与get_headers()类似
  $argc:传递给脚本的参数数目。
  $argv:传递给脚本的参数数组。
预定义异常：
预定义接口：
上下文选项和参数：
支持的协议和封装协议：
函数：
  
  constant()来获取常量的值，也可以获取常量名是动态的常量值。
  
  define()定义常量
  defined()函数检查是否定义了某个常量。
  
  error_reporting()
  
  get_defined_constants()可以获得所有已定义的常量列表。
  getenv()
  get_headers()
  
  move_uploaded_file()
  
  import_request_variables()
  
  session_start()
  setcookie()设置cookie 
  substr()函数截取字符串
  substr_replace() 字符串替换
  set_error_handler()
  shell_exec()

































*/
?>